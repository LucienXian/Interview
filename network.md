* TCP/UDP的区别，如何实现拥塞控制，如何实现可靠传输？UDP的应用？

1. 区别：TCP是一种面向连接的，可靠性的，基于字节流的通讯协议；UDP是一种无连接的，不可开的通信协议；TCP首部20个字节，UDP8个；TCP有拥塞控制、流量控制等可靠性机制，UDP没有；
2. 拥塞控制：慢启动、拥塞避免、拥塞发生，快速回复
3. 可靠传输：拥塞控制、流量控制、校验和、数据分片和排序、确认重传；
4. UDP应用：DNS，即时通讯；
5. UDP头部：8bytes，源端口和目的端口，长度和校验和



* TCP三次握手

服务端经过socket，bind，listen之后，被动打开，进入LISTEN状态，客户端执行socket和connect，开始执行三次握手：

1. 客户端发送一个syn分节，内含isn等信息，客户端从closed变成SYN_SENT；
2. 服务端接收到syn，然后发送一个响应ACK和一个自己的syn，从LISTEN变成SYN_RECD；
3. 客户端对服务端就行ack，两边进入established状态；



* 四次握手

1. a执行close，进入主动关闭状态，发送fin给b，a进入FIN_WAIT_1状态；
2. b接收到fin，发送ack，进入CLOSE_WAIT状态；a接收到后进入FIN_WAIT_2状态；
3. b发送fin，进入LASK_WAIT状态；
4. a接收到fin，发送ack，进入TIME_WAIT状态，经过两个msl之后进入closed



* TIME_WAIT

1. 保证tcp正确关闭，防止ack丢失；
2. 使得老的分节在网络消逝，避免重复在同一个端口建立连接时接收到老分节；

问题：time_wait过多，占用端口



* 流量控制

，通过发送，接收端口去避免，主要发生原因是，发送方数据发送太快，接收方来不及接收；

维护一个接收窗口，记录一个叫rwnd的变量，这个变量表示接收窗口还有多少空间。并且这个变量会被塞进分节中传回给发送方。



* 拥塞控制

1. 慢启动：设置一个拥塞窗口阈值，指数增大；
2. 拥塞避免：到达阈值后，变成线性增加；
3. 快速重传：要求接收方在接收到一个失序的报文时马上进行确认；（例如收到重复的三个报文M２，发送方需要马上发送三个M3）
4. 快速回复：重设拥塞窗口，执行拥塞避免；





* 浏览器输入网址发生什么

1. 查找url对应的ip地址，通过dns，从缓存中找；
2. 通过ip地址向web服务器发送请求
3. 服务器响应请求
4. 浏览器解析内容





* arp协议

IP地址转换长mac地址

1. 每台主机都会有一个ARP高速缓存，缓存中会建立一个ARP列表；
2. 当源主机要发送数据时，先根据ip地址去ARP列表中查找相应的MAC地址。如果有，则直接发送数据；如果无，则向局域网广播ARP包（包含源ip，源MAC，目的ip）；
3. 局域网内的主机收到ARP包之后，检查ip地址，如果不是自己的ip地址，则丢弃。如果是，则更新自己的ARP列表，并发送ARP响应，填充自己的MAC地址；
4. 源主机收到ARP响应后，更新自己的ARP列表，发送数据；



* HTTP中GET和POST的区别

1. GET是请求服务器资源；POST是表示提交数据的请求，可能修改服务器内容；
2. GET请求的数据放在URL后面，而POST则是HTTP包体内；   



* TCP的报头

有20个字节，包括了源和目的端口号，顺序号和确认号，头部长，保留位，窗口大小，校验和等



* session和cookie

session是一种抽象概念，由于http是一个无状态的连接，所以需要某种机制来保证服务器识别客户端的身份，就是通过session机制。一般来说，服务器端会为客户端创建一个特定的session，客户端访问服务端时会将sessionid保存到cookie中，然后将cookie传送到服务器端



* https

http over ssl，指的是经由http通信，对数据包进行ssl加密传输。用非对称加密来传输数字证书，用对称加密传输数据包

http的端口是80，https的端口是443。



* nagle算法 && clark算法

糊涂窗口综合征，即发送方发送数据很缓慢，或者接收方处理数据缓慢，或者两者都有。

解决方法：

* 如果是接收端造成，Clark算法，只要有数据到达就确认，并且宣布窗口为0，直到缓存空间能放下最大长度的报文段；
* 如果是发送端造成，nagle算法，在任意时刻只允许一个未被确认的小段（长度小于mss的端）在网络中，可以通过设置TCP_NODELAY选项（意在禁止nagle），则允许发送；



* ip为什么要分片处理

因为一个IP数据报的长度可能超过以太帧的限制，要迎合数据链路层的实现。



- select, poll和epoll的区别

[点击](http://www.lucienxian.top/2018/03/17/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94chap6/)

epoll：epoll同样只告知哪些文件描述符准备就绪了，但我们调用epoll_wait()获得就绪的文件描述符时，返回的不是实际的描述符，而是代表就绪描述符数量的值。通过epoll_ctl注册fd，一旦该fd就绪，内核就会通过回调的方式激活fd。fd_set在内核与用户态之间只需要复制一次。

区别：

1. epoll和poll都没有最大并发连接数的限制，poll是基于链表存储的，而epoll的最大连接数上限很大；
2. fd增加后，io效率上select和poll都是线性增长的，因为每次调用时都要遍历所有的fd_set；
3. 消息传递不同，select和poll：内核需要将消息拷贝到用户空间；epoll则是内核和用户空间共享一块内存(mmap)



* epoll接口函数调用过程

1. epoll_creat()：创建一个epoll专用的文件描述符，size参数意义不大
2. epoll_ctl()：epoll的事件注册函数，可以通过指定宏来告知需要的操作，是删除一个fd，还是增加一个fd，还是修改。
3. epoll_wait()：等待事件的产生，收集在epoll监控的事件中已经发送的事件。



* epoll中LT和ET的使用场景

用ET，可以便利地处理EPOLLOUT事件，因为EPOLLOUT触发后会一直读取数据直到返回EAGAIN为止，避免了打开关闭EPOLLOUT，提高了效率。而在处理并发大流量时，LT模式会会不断开关EPOLLOUT，影响性能。



* 什么时候触发EPOLLOUT事件，什么时候产生EPOLLINT事件

1. 当缓冲区从不可写到可写，就会触发EPOLLOUT事件；
2. 只有当对端有数据写入时才会触发EPOLLINT事件；



* UDP可以connect吗

可以，不像TCP那样进行三次握手，只是记录下对端的IP和port。



* RST什么时候出现

1. 建立连接发送SYN时，对端没有监听端口；
2. 请求超时；
3. 提前关闭；
4. 在一个关闭的socket上收到收据；



* 浏览器输入网址发生了什么

1. 通过DNS，根据域名去寻找IP地址（现在浏览器DNS缓存中搜索，然后是操作系统缓存，再向本地配置的DNS服务器发起域名解析请求）；
2. 建立TCP连接
3. 发起HTTP请求
4. 接受响应
5. 浏览器解析内容



* 如何处理syn flood

1. 内核参数调优；
2. 禁止部分IP；