* TCP/UDP的区别，如何实现拥塞控制，如何实现可靠传输？UDP的应用？

1. 区别：TCP是一种面向连接的，可靠性的，基于字节流的通讯协议；UDP是一种无连接的，不可开的通信协议；TCP首部20个字节，UDP8个；TCP有拥塞控制、流量控制等可靠性机制，UDP没有；
2. 拥塞控制：慢启动、拥塞避免、拥塞发生，快速回复
3. 可靠传输：拥塞控制、流量控制、校验和、数据分片和排序、确认重传；
4. UDP应用：DNS，即时通讯；
5. UDP头部：8bytes，源端口和目的端口，长度和校验和

* udp调用connect有什么作用

内核仅仅把对端ip&port记录下来；UDP多次调用connect有两种用途:1,指定一个新的ip&port连结. 2,断开和之前的ip&port的连结；断开连接,需要将connect第二个参数中的sin_family设置成 AF_UNSPEC即可

* tcp时序图、状态图

https://blog.csdn.net/abc_ii/article/details/18603469

* TCP的报头

有20个字节，包括了源和目的端口号，顺序号和确认号，头部长，保留位，窗口大小，校验和等


* TCP三次握手

服务端经过socket，bind，listen之后，被动打开，进入LISTEN状态，客户端执行socket和connect，开始执行三次握手：

1. 客户端发送一个syn分节，内含isn等信息，客户端从closed变成SYN_SENT；
2. 服务端接收到syn，然后发送一个响应ACK和一个自己的syn，从LISTEN变成SYN_RECD；
3. 客户端对服务端就行ack，两边进入established状态；



* 四次握手

1. a执行close，进入主动关闭状态，发送fin给b，a进入FIN_WAIT_1状态；
2. b接收到fin，发送ack，进入CLOSE_WAIT状态；a接收到后进入FIN_WAIT_2状态；
3. b发送fin，进入LASK_WAIT状态；
4. a接收到fin，发送ack，进入TIME_WAIT状态，经过两个msl之后进入closed



* TIME_WAIT

1. 保证tcp正确关闭，防止ack丢失；
2. 使得老的分节在网络消逝，避免重复在同一个端口建立连接时接收到老分节；

问题：time_wait过多，占用端口

解决方法：通过socket的选项SO_REUSEADDR来强制进程立即使用处于time_wait状态的连接占用的端口，此外也可以通过修改内核参数数/proc/sys/net/ipv4/tcp_tw/recycle来快速回收被关闭的socket,从而使得tcp连接根本不进入time_wait状态


* 滑动窗口

该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量

* 流量控制

，通过发送，接收端口去避免，主要发生原因是，发送方数据发送太快，接收方来不及接收；

维护一个接收窗口，记录一个叫rwnd的变量，这个变量表示接收窗口还有多少空间。并且这个变量会被塞进分节中传回给发送方。



* 拥塞控制

1. 慢启动：设置一个拥塞窗口阈值，指数增大；
2. 拥塞避免：到达阈值后，变成线性增加；
3. 快速重传：要求接收方在接收到一个失序的报文时马上进行确认；（例如收到重复的三个报文M２，发送方需要马上发送三个M3）
4. 快速回复：重设拥塞窗口，执行拥塞避免；





* 浏览器输入网址发生什么

1. 查找url对应的ip地址，通过dns，从缓存中找；
2. 通过ip地址向web服务器发送请求
3. 服务器响应请求
4. 浏览器解析内容





* arp协议

IP地址转换长mac地址

1. 每台主机都会有一个ARP高速缓存，缓存中会建立一个ARP列表；
2. 当源主机要发送数据时，先根据ip地址去ARP列表中查找相应的MAC地址。如果有，则直接发送数据；如果无，则向局域网广播ARP包（包含源ip，源MAC，目的ip）；
3. 局域网内的主机收到ARP包之后，检查ip地址，如果不是自己的ip地址，则丢弃。如果是，则更新自己的ARP列表，并发送ARP响应，填充自己的MAC地址；
4. 源主机收到ARP响应后，更新自己的ARP列表，发送数据；



* HTTP中GET和POST的区别

1. GET是请求服务器资源；POST是表示提交数据的请求，可能修改服务器内容；
2. GET请求的数据放在URL后面，而POST则是HTTP包体内；   




* session和cookie

session是一种抽象概念，由于http是一个无状态的连接，所以需要某种机制来保证服务器识别客户端的身份，就是通过session机制。一般来说，服务器端会为客户端创建一个特定的session，客户端访问服务端时会将sessionid保存到cookie中，然后将cookie传送到服务器端



* https

http over ssl，指的是经由http通信，对数据包进行ssl加密传输。用非对称加密来传输数字证书，用对称加密传输数据包

http的端口是80，https的端口是443。



* nagle算法 && clark算法

糊涂窗口综合征，即发送方发送数据很缓慢，或者接收方处理数据缓慢，或者两者都有。

解决方法：

* 如果是接收端造成，Clark算法，只要有数据到达就确认，并且宣布窗口为0，直到缓存空间能放下最大长度的报文段；
* 如果是发送端造成，nagle算法，在任意时刻只允许一个未被确认的小段（长度小于mss的端）在网络中，可以通过设置TCP_NODELAY选项（意在禁止nagle），则允许发送；



* ip为什么要分片处理

因为一个IP数据报的长度可能超过以太帧的限制，要迎合数据链路层的实现。


* connect会阻塞，怎么解决
1. 将socket句柄设置为非阻塞状态，返回后用select检测状态
2. 采用信号处理函数设置阻塞超时控制

ref:[参考](https://michaelyou.github.io/2015/03/03/connect%E5%87%BD%E6%95%B0%E4%BC%9A%E9%98%BB%E5%A1%9E%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/)


- select, poll和epoll的区别

[点击](http://www.lucienxian.top/2018/03/17/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94chap6/)

epoll：epoll同样只告知哪些文件描述符准备就绪了，但我们调用epoll_wait()获得就绪的文件描述符时，返回的不是实际的描述符，而是代表就绪描述符数量的值。通过epoll_ctl注册fd，一旦该fd就绪，内核就会通过回调的方式激活fd。fd_set在内核与用户态之间只需要复制一次。

区别：

1. epoll和poll都没有最大并发连接数的限制，poll是基于链表存储的，而epoll的最大连接数上限很大；
2. fd增加后，io效率上select和poll都是线性增长的，因为每次调用时都要遍历所有的fd_set；
3. 消息传递不同，select和poll：内核需要将消息拷贝到用户空间；epoll则是内核和用户空间共享一块内存(mmap)



* epoll接口函数调用过程

1. epoll_creat()：创建一个epoll专用的文件描述符，size参数意义不大
2. epoll_ctl()：epoll的事件注册函数，可以通过指定宏来告知需要的操作，是删除一个fd，还是增加一个fd，还是修改。
3. epoll_wait()：等待事件的产生，收集在epoll监控的事件中已经发送的事件。



* epoll中LT和ET的使用场景

LT模式：LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。只要缓冲内容不为空，LT模式返回读就绪；只要缓冲区还不满，LT模式会返回写就绪；

ET模式：ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。当缓冲区由不可读变为可读的时候，当有新数据到达时，当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时，返回
读就绪；当缓冲区由不可写变为可写时，当有旧数据被发送走，当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时，返回
写就绪。

ET模式的加速效用仍需要更多的benchmark确认

用ET，可以便利地处理EPOLLOUT事件，因为EPOLLOUT触发后会一直读取数据直到返回EAGAIN为止，避免了打开关闭EPOLLOUT，提高了效率。而在处理并发大流量时，LT模式会会不断开关EPOLLOUT，影响性能。



* 什么时候触发EPOLLOUT事件，什么时候产生EPOLLINT事件

1. 当缓冲区从不可写到可写，就会触发EPOLLOUT事件；
2. 只有当对端有数据写入时才会触发EPOLLINT事件；


* 如果select返回可读，结果只读到0字节

建立连接超时


* RST什么时候出现

1. 建立连接发送SYN时，对端没有监听端口；
2. 请求超时；
3. 提前关闭；
4. 在一个关闭的socket上收到收据；





* 浏览器输入网址发生了什么

1. 通过DNS，根据域名去寻找IP地址（现在浏览器DNS缓存中搜索，然后是操作系统缓存，再向本地配置的DNS服务器发起域名解析请求）；
2. 建立TCP连接
3. 发起HTTP请求
4. 接受响应
5. 浏览器解析内容


* 如何处理syn flood

1. 内核参数调优；
2. 禁止部分IP；

* socket什么时候可读

1. socket接收缓冲区中已经接收的数据的字节数大于等于socket接收缓冲区低潮限度的当前值;
2. 被动关闭方接收到fin时；
3. 有一个socket有异常错误条件待处理；

* keepalive 是什么？

1. TCP: 当客户端端等待超过一定时间后自动给服务端发送一个空的报文，如果对方回复了这个报文证明连接还存活着，如果对方没有报文返回且进行了多次尝试都是一样，那么就认为连接已经丢失，客户端就没必要继续保持连接了。内核中有三个选项影响KEEP_ALIVE，然后在应用中socket设置开启SO_KEEPALIVE；
2. HTTP: 开启HTTP Keep-Alive之后，能复用已有的TCP链接，当前一个请求已经响应完毕，服务器端没有立即关闭TCP链接，而是等待一段时间接收浏览器端可能发送过来的第二个请求，HTTP/1.1之后默认开启Keep-Alive, 在HTTP的头域中增加Connection选项

* tcp的选项有哪些？

1. MSS：tcp期望从对端得到的最大报文长度；
2. EOL：指示选项列表的结束；
3. NOP：用在选项之间或者选项结束，作对齐使用；

* http状态码

1. 状态码类别

|      |       类别       |            原因            |
| ---- | :--------------: | :------------------------: |
| 1XX  |   信息性状态码   |     接受的请求正在处理     |
| 2XX  |    成功状态码    |      请求正常处理完毕      |
| 3XX  |   重定向状态码   | 需要进行附加操作以完成请求 |
| 4XX  | 客户端错误状态码 |     服务器无法处理请求     |
| 5XX  | 服务器错误状态码 |     服务器处理请求错误     |

2. 2xx

200 OK

204 No Content

206 Partial Content：对部分资源的请求

3. 3xx

301 Moved Permanently：表示请求的资源已经分配了新的URI，以后应该使用资源location首部字段提示的URI重新保存、

302 Found：代表资源不是永久转移，与301类似

4. 4xx

404 Not found：客户端请求到了不合法的资源；客户端原来可以请求到，但现在没有了

400 Bad Request：报文中存在错误

403 Forbidden：不允许访问那个资源

5. 5xx

500 Internal Server Error：一般是应用存在bug

503 Service Unavaliable：服务器停机维护中或者是超负载
