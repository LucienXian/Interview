C++



* 悬空指针和野指针有什么区别？

dangling指针是指该指针曾经指向有效地址，但现在地址已经不再有效。通常是因为指向的内存地址被释放了而不再有效了，不能再通过该指针访问原来的地址空间；而wild指针则是指这样的指针：它没有被正确初始化而指向了一个随机的内存地址。

* 指针和引用的区别

1. 指针是一个变量，占据内存；引用只是一个别名；
2. 引用必须被初始化，而指针可以不；
3. 不存在空引用，但有指向null的指针；
4. 指针可以改变指向，引用不可以；

* 什么是内存泄漏？怎么产生的？如何检测？

简单来说，就是申请了一块地址空间，使用完毕后没有释放掉，随着系统的运行，内存申请得越来越多，直到全部内存用完，系统崩溃。

1. 将使用的内存的指针以链表进行管理，使用完删掉，程序结束时就检查链表；
2. 使用智能指针；
3. GNU C库中的malloc实现提供了一些简单的[方法](https://stackoverflow.com/questions/18455698/lightweight-memory-leak-debugging-on-linux)来检测此类泄漏并获取一些信息以查找位置。 要执行此操作，必须以特殊模式启动应用程序，该模式由环境变量启用。mtrace()，编译成动态链接库，连接进去运行。
4. vs设置成debug模式会进行检查

* struct和class的区别默认的访问控制不同，struct是public的，class是private


* sizeof和strlen的区别

sizeof是运算符，编译时就运算好了，返回的是能保证容纳实现的最大容量；strlen是函数，运行时计算，参数是char*，它一个一个遍历，直到遇到NULL，返回的长度是不包括NULL的。

* decltype

用typeid可以在运行时拿到type_info的信息，RTTI的效率是比较低的。由于泛型编程的提出，我们需要编译时的类型推导，除了auto之外，还有c++11提出decltype。

decltype的推导规则：

* 如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。
* 否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&&
* 否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T&。
* 否则，假设e的类型是T，则decltype（e）为T。



* C++中函数指针的作用？由那些属性唯一决定一个函数指针

1. 作为回调函数；
2. 多态性；

可以用函数地址唯一决定函数指针。



* C++中如何唯一确定一个重载函数

通过参数表，参数个数，参数类型



* strcat,strcpy,strncpy,memset,memcpy的内部实现



* new operator, operator new, placement new的区别

1. new 调用operator new分配足够的空间，然后调用相关构造函数，不可重载；
2. operator new只分配空间；
3. placement new是operator new的重载，是一个标准的、全局的版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针，placement允许你在一个已经分配好的内存上构造新对象；



* new, delete和malloc,free的区别

1. 一个是库函数，一个是操作符；
2. 一个能自动计算大小，另一个需要手动指定大小；
3. 一个能初始化并且构造，另一个不能执行构造/析构函数



* 类继承的情况下，构造调用顺序和析构调用顺序

基类构造（先是虚基类再到非虚基类），成员对象，子类构造



* 如何禁止自动生成拷贝构造函数

1. 将拷贝构造函数声明成private，并且不去实现；
2. 继承一个uncopyable类；
3. c++11，使用delete关键字，禁用该方法；



* 类的大小

1. 为类的成员变量大小之和，同时需要满足一些对齐要求（例如上面的例子中对齐为１个字节）
2. 编译器额外加入的大小，例如虚函数的指针，虚继承，多重继承（与内存位数有关）
3. 与类的构造析构和成员函数无关
4. 继承计算大小时会把私有变量计算在内
5. 空类为1；




*  define与inline区别

define是在预处理阶段做常量替换，不做类型检查，也不检查返回值，是不安全的；

而inline则是由编译器控制的，编译器在检查inline函数是否符合标准之后（比如是否有递归，是否过于复杂），会在编译阶段将函数展开。取消参数压栈。如果无法展开，函数就会变成一个static函数



- 多态性都有哪些

编译时多态：函数模板实现；

运行时多态：虚函数实现；



- 必须在构造函数初始化式里进行初始化的数据成员有哪些

1. 类内有对象成员，它没有默认的构造函数，只有一个带参数的构造函数；
2. const成员；
3. 引用；



- typeid

typeid是c++的一个关键字，该操作符的返回结果是一个const type_info&,这样一个对象的name成员函数会返回一个C-style的字符串。



- c++中两个类互相引用的解决方法

1. 写两个头文件和两个.cpp文件分别定义类A和B；
2. 其中A的头文件中引进B.h；
3. B的头文件就不引进A的头文件，而是用extern来声明类A，并且对于A的使用应该通过指针实现；





* 纯虚函数可以有函数体吗

可以



* 如何定义一个在只能在堆上/栈上的对象

1. 只在堆：将析构函数定义为私有，编译器会检查析构函数的访问性，只能调用new来生成对象；
2. 只在栈：将operator new定义为私有；




* vevctor扩容为什么1.5倍或2倍

选2或者1.5是因为之前分配内存有可能被重复使用，对缓存比较友好。
